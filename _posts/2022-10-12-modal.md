---
title: "리액트에서 라이브러리 없이 모달 창 구현하기"
excerpt: "기능의 본질에 대해서 생각하라"

categories:
    - react
tags:
    - react

toc: true
toc_sticky: true
---

## 개요

웹 사이트에서 사용자의 관심을 끄는 방법에는 정말 많은 방법이 있지만, 가장 흔한 것이 `팝업 창`이나 `모달 창`이다. `모달 창`의 본질과 `모달 창`을 어떻게 구현할지 탐구한 다음 리액트에서 라이브러리 없이 바닥부터 `모달 창`을 구현해보자.

## 모달 창이란?
어떤 기능을 구현하기로 했을 때, 가장 먼저 생각해야할 것은 **기능의 본질**이다. 기능이 어떤 역할을 하고, 무슨 의미를 가지는 지만 안다면 ctrl+c ctrl+v 없이도 얼렁뚱땅 돌아가게는 할 수 있다. ~~그렇다고 구글링을 하지 않는 것은 아니다~~. 이는 개발 과정에서 가장 중요한 부분은 아닐 테지만, 개발을 공부하고 있는 학생(me)입장에서는 상당히 중요하다고 생각한다. 초심자 입장에서는 힘들고 어렵게 배우는 것이 최고이니까 말이다.

`모달 창`이란 과연 무엇인가? 

> 모달창은 기존의 브라우저 페이지 위에 새로운 윈도우 창이 아닌, 레이어를 까는 것을 말한다. 모달창은 제거를 하지 않고도 페이지를 이동하면 자연히 사라진다. 기존의 페이지와 부모-자식 관계를 갖는다. 브라우저의 새 창 제어 옵션에는 전혀 영향을 받지 않는다.

/////// 모달 사진(완성체)

지금까지 사용해본 웹 어플리케이션에서 만났던 모달 창은 어떤 형태였는지 다시 생각해보자.

- 클릭하는 순간 배경이 전체적으로 어두워지고, 오직 작은 사이즈의 모달 창만 눈에 띄었다.
- 모달 내부의 X버튼이나 모달 외부를 클릭할 경우 모달 창이 닫혔다.
- 페이지처럼 동작하지 않았다.

일단 이 정도가 생각난다. 그렇다면 여기서 자바스크립트로 구현할 수 있는 요소들을 뽑아내 보자.

- 클릭하는 순간 모달 컴포넌트를 제외한 `background` 값이 어둡게 변경된다.
- 모달 컴포넌트 off는 내부의 버튼과 외부 영역에 `이벤트 핸들러`를 등록하여 관리한다.
- `스크롤`이 불가능하게끔 한다.

이제 어떻게 구현해야 할 지 조금은 감을 잡았으니, 천천히 코드를 짜 보도록 하자.

## 1. show/hide

모달 상태를 관리할 state를 만든다.

```jsx
// 상위 컴포넌트(모달을 위치시킬 곳)
const [isModal, setIsModal] = useState(false);
```

모달 show/hide 상태의 T/F 여부에 따라 `조건부 렌더링`되도록 `단축 평가`를 사용한다.

```jsx
// 상위 컴포넌트(모달을 위치시킬 곳)
{isModal && <Modal setIsModal={setIsModal} />}
```

특정 버튼을 클릭하면 모달 상태가 true가 되고, 단축 평가에 의해 렌더링되도록 `이벤트 핸들러`를 할당한다.

```jsx
// 상위 컴포넌트(모달을 위치시킬 곳)
/* 생략 */
<button className="Card" onClick={() => {
        setIsModal(true);
}} />
/* 생략 */
```

모달 컴포넌트는 상위 컴포넌트에게서 모달 상태를 관리하는 함수를 props로 전달받아 모달이 hide되게 할 수 있다. `닫기 버튼(X)`을 만들어 이벤트를 핸들링한다.

```jsx
// 모달 컴포넌트
/* 생략*/
const Modal = ( {setIsModal} ) => {

    const handleClick = () => {
        setIsModal(false);
    };

    return (
        <div className="Modal">
                <button onClick={handleClick}>X</button>  
        </div>
    )
}

export default Modal;
```


## 2. 배경을 어둡게

모달 컴포넌트

```css
.Modal {
    display: flex !important;
    justify-content: center;
    align-items: center;

    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;

    background-color: rgba(0,0,0,0.3);
}
```

## 3. 스크롤 불가능

## 더 생각해보기 - 모달 컴포넌트 분리 : portal

### 전역 모달 창의 문제점

이제 우리는 좀 더 깊이 생각해볼 필요가 있다. 지금까지 구현한 모달은 전역상태(Boolean)을 통해 show/hide했다. 이 방법은 겉으로 보면은 ~~일단은 돌아가니까~~ 문제가 없어 보이지만, 여러가지 문제점이 있다.

- DOM tree 상위단에 DOM노드를 생성하여 단순한 기능을 하는 모달(알람 기능 등과 같은 기존 컴포넌트들과 관련이 없는 기능)의 경우에도 전역상태에 의존하게 된다.
- 모달이 show된 상태에서 부모 컴포넌트가 리렌더 될 경우 리액트의 리렌더링 기준에 따라 자식인 모달 역시 의도치 않은 영향을 받게 된다.
- 부모 컴포넌트의 스타일링에 제약을 받아 z-index등의 번거로운 작업을 해야 한다.

이 모든 문제는 결국 **모달 창이 DOM tree 상에서 부모-자식 간의 제약에 얽매여 있기 때문**이다. 이는 `Portal`을 사용하여 해결할 수 있다. 

### Portal이란?

Portal은

또한, Portal에 렌더링된 자식요소는 이벤트 버블링이 반영되기 때문에 부모 요소와의 통신 측면에서도 유용하다.

## 더 생각해보기 - iframe